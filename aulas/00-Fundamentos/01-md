# Godot Architecture: O Modelo Mental do Engenheiro

Muitos acham que o diferencial da Godot é só o GDScript ou ser Open Source, mas a verdade está na sua arquitetura de objetos.

Para dominar a Godot, você precisa parar de pensar em "Scripts" e começar a pensar em **Classes e Objetos**.

A Godot é inteiramente baseada em **Herança** e **Composição**.

- **Nodes** = Herança de Comportamento (Lógica)
- **Resources** = Herança de Dados (Configuração)
- **Signals** = O Padrão Observer (Comunicação Desacoplada)
- **Scenes** = Composição (Blueprints de Árvores)
- **SceneTree** = O Gerenciador de Ciclo de Vida (O Mundo)
- **Inspector** = A Interface de Injeção de Dependência

---

## 1. Nodes: Herança de Objetos

Na Godot, quando você cria um script `player.gd` e o anexa a um `CharacterBody2D`, você não está "adicionando um script ao objeto".

Você está criando uma **Nova Classe** que herda de `CharacterBody2D`.

```gdscript
# player.gd
extends CharacterBody2D
```

Isso significa que seu Player **É UM** CharacterBody2D. Ele herda todas as propriedades (`velocity`, `position`) e métodos (`move_and_slide()`) do pai.

**A Regra de Ouro:**
Não use Nodes para guardar dados puros (como `max_health` ou `item_price`). Nodes são caros para a CPU. Eles servem para **fazer coisas** (mover, colidir, tocar som).

---

## 2. Resources: Herança de Dados

Se Nodes são os "Operários", Resources são as "Pranchetas".

Um `Resource` é um objeto de dados serializável. Enquanto iniciantes usam JSON ou Dicionários, profissionais usam Resources porque eles suportam **Herança** e **Tipagem**.

**Exemplo:**
Você cria um script `EnemyStats.gd` (`extends Resource`).
Depois, cria arquivos `.tres` no editor: `goblin.tres`, `orc.tres`.

Se você adicionar uma variável `armor` no script `EnemyStats.gd`, **todos** os arquivos `.tres` ganham esse campo automaticamente. Tente fazer isso com JSON e veja o caos.

> **Machi Way:** Use Resources para tudo que for "Design": atributos de personagens, tabelas de loot, configurações de armas.

---

## 3. Signals: Emissão de Eventos (Observer Pattern)

Como fazer o `Player` avisar a `HealthBar` que tomou dano, sem que o Player saiba que a HealthBar existe?

**Errado (Acoplado):**
```gdscript
# player.gd
get_parent().get_node("UI/HealthBar").update_health(hp) # Quebra se você mudar a UI de lugar
```

**Certo (Sinais):**
```gdscript
# player.gd
signal health_changed(new_hp)

func take_damage(amount):
    hp -= amount
    health_changed.emit(hp) # O Player apenas "grita". Não importa quem ouve.
```

Isso é o **Padrão Observer**. O emissor não conhece o receptor. Isso permite que você delete a UI inteira e o Player continue funcionando sem erros.

---

## 4. Scenes: Composição (Blueprints)

Uma Cena (`.tscn`) não é um objeto. É uma **Planta Baixa (Blueprint)**.

Quando você arrasta a cena `Sword.tscn` para dentro da cena `Player.tscn`, você está usando **Composição**.
O Player **TEM UMA** Espada.

A arquitetura da Godot favorece Composição sobre Herança complexa.
Em vez de: `Inimigo -> InimigoQueAtira -> InimigoQueAtiraFogo`
Faça: `Inimigo` com um nó filho `ShooterComponent` e um nó filho `FireDamageComponent`.

---

## 5. SceneTree: Gerenciamento de Ambientes

A `SceneTree` é o "Mundo". É ela quem chama `_process` e `_physics_process` em todos os nós ativos.

Entender a SceneTree é entender o **Ciclo de Vida**:
1. `_init()`: O objeto nasce na memória (ainda fora da árvore).
2. `_enter_tree()`: O objeto entra no mundo.
3. `_ready()`: O objeto e **todos os seus filhos** estão prontos. (Aqui começa o jogo).
4. `_exit_tree()`: O objeto saiu do mundo (mas ainda pode existir na memória).

**Dica de Performance:** Adicionar e remover nós da SceneTree é custoso. Para projéteis e efeitos, use **Object Pooling** (esconder e reutilizar em vez de criar e destruir).

---

## 6. Inspector: Editor de Propriedades

O Inspector não é apenas para ver valores. É a sua interface de **Injeção de Dependência**.

Em vez de buscar nós via código (`$Path/To/Node`), exporte variáveis:

```gdscript
@export var gun: Weapon
@export var stats: EnemyStats
```

Isso permite que você arraste nós e resources diretamente no editor. Se você mudar o nome ou o caminho do nó, a referência **não quebra**. O Inspector é a ferramenta que conecta seus sistemas de forma segura.
