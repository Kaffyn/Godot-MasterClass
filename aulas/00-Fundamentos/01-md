# Godot Architecture: O Modelo Mental do Engenheiro

Muitos acham que o diferencial da Godot é só o GDScript ou ser Open Source, mas a verdade está na sua arquitetura de objetos.

Para dominar a Godot, você precisa parar de pensar em "Scripts" e começar a pensar em **Classes e Objetos**.

A Godot é inteiramente baseada em **Herança** e **Composição**.

- **Nodes** = Herança de Comportamento (Lógica)
- **Resources** = Herança de Dados (Configuração)
- **Signals** = O Padrão Observer (Comunicação Desacoplada)
- **Scenes** = Composição (Blueprints de Árvores)
- **SceneTree** = O Gerenciador de Ciclo de Vida (O Mundo)
- **Inspector** = A Interface de Injeção de Dependência

---

## 0. Herança: O DNA do seu Código

Antes de falarmos de Godot, precisamos falar de Biologia (ou quase isso).

**Herança** é a capacidade de uma Classe (Filho) receber todas as características e comportamentos de outra Classe (Pai).

Quando dizemos que `Cachorro` herda de `Animal`:

1. **Variáveis (O que ele tem):** Se `Animal` tem `vida` e `peso`, o `Cachorro` automaticamente tem `vida` e `peso`.
2. **Funções (O que ele faz):** Se `Animal` tem `comer()` e `dormir()`, o `Cachorro` sabe `comer()` e `dormir()`.
3. **Extensão:** O `Cachorro` pode adicionar coisas novas, como `latir()`.

Na Godot, isso é definido pela palavra-chave `extends`.

> **Conceito Chave:** Herança cria uma relação **"É UM"**.
>
> - O Player **É UM** CharacterBody2D.
> - O Inimigo **É UM** CharacterBody2D.
> - A Parede **É UM** StaticBody2D.

Se você herda de algo, você ganha todos os poderes daquilo de graça. Mas cuidado: herança em excesso cria rigidez. Use com sabedoria.

--

## 1. Nodes: A Cadeia de Especialização

Já entendemos que herança é "receber poderes". Na Godot, os Nodes são organizados em uma **Cadeia de Especialização**.

Não olhe para um `CharacterBody2D` como uma peça única. Olhe para a árvore genealógica dele:

1. **Object:** A base de tudo (gerencia memória).
2. **Node:** Entra na SceneTree, tem nome e parentesco.
3. **Node2D:** Ganha `position`, `rotation`, `scale`.
4. **CollisionObject2D:** Ganha formas de colisão.
5. **CharacterBody2D:** Ganha `move_and_slide()`.

Quando você faz `extends CharacterBody2D`, seu script é o próximo passo dessa evolução.

**Por que isso importa?**
Se você precisa apenas de uma posição no mundo, use `Node2D` (leve). Se precisa de física, use `CharacterBody2D` (pesado). Escolher o nó certo é escolher a "bagagem" certa de herança para carregar.

---

## 2. Resources: Polimorfismo e Dados

Resources são dados, mas também são classes. Isso permite o **Polimorfismo**: a capacidade de substituir um objeto por outro mais complexo, sem que o sistema perceba.

### O Caso do AudioStream

Um `AudioStreamPlayer` precisa de um `AudioStream` para tocar.
Normalmente, você arrasta um arquivo `.wav` (que é um `AudioStreamWAV`).

Mas a Godot tem um recurso nativo chamado **AudioStreamRandomizer**.
Ele **herda** de `AudioStream`.

Isso significa que você pode colocar um `AudioStreamRandomizer` (que contém 10 sons diferentes e varia o pitch) no lugar onde iria um simples `.wav`.

O `AudioStreamPlayer` não sabe a diferença. Ele só sabe "tocar o stream".
Isso é arquitetura robusta: você aumentou a complexidade do som (Game Feel) sem mudar uma linha de código do player.

> **Machi Way:** Use Resources para definir _comportamentos intercambiáveis_. Stats, Tabelas de Loot, e até IAs podem ser Resources.

---

## 3. Signals: Emissão de Eventos (Observer Pattern)

Como fazer o `Player` avisar a `HealthBar` que tomou dano, sem que o Player saiba que a HealthBar existe?

**Errado (Acoplado):**

```gdscript
# player.gd
get_parent().get_node("UI/HealthBar").update_health(hp) # Quebra se você mudar a UI de lugar
```

**Certo (Sinais):**

```gdscript
# player.gd
signal health_changed(new_hp)

func take_damage(amount):
    hp -= amount
    health_changed.emit(hp) # O Player apenas "grita". Não importa quem ouve.
```

Isso é o **Padrão Observer**. O emissor não conhece o receptor. Isso permite que você delete a UI inteira e o Player continue funcionando sem erros.

---

## 4. Scenes: Composição (Blueprints)

Uma Cena (`.tscn`) não é um objeto. É uma **Planta Baixa (Blueprint)**.

Quando você arrasta a cena `Sword.tscn` para dentro da cena `Player.tscn`, você está usando **Composição**.
O Player **TEM UMA** Espada.

A arquitetura da Godot favorece Composição sobre Herança complexa.
Em vez de: `Inimigo -> InimigoQueAtira -> InimigoQueAtiraFogo`
Faça: `Inimigo` com um nó filho `ShooterComponent` e um nó filho `FireDamageComponent`.

---

## 5. SceneTree: Gerenciamento de Ambientes

A `SceneTree` é o "Mundo". É ela quem chama `_process` e `_physics_process` em todos os nós ativos.

Entender a SceneTree é entender o **Ciclo de Vida**:

1. `_init()`: O objeto nasce na memória (ainda fora da árvore).
2. `_enter_tree()`: O objeto entra no mundo.
3. `_ready()`: O objeto e **todos os seus filhos** estão prontos. (Aqui começa o jogo).
4. `_exit_tree()`: O objeto saiu do mundo (mas ainda pode existir na memória).

**Dica de Performance:** Adicionar e remover nós da SceneTree é custoso. Para projéteis e efeitos, use **Object Pooling** (esconder e reutilizar em vez de criar e destruir).

---

## 6. Inspector: Editor de Propriedades

O Inspector não é apenas para ver valores. É a sua interface de **Injeção de Dependência**.

Em vez de buscar nós via código (`$Path/To/Node`), exporte variáveis:

```gdscript
@export var gun: Weapon
@export var stats: EnemyStats
```

Isso permite que você arraste nós e resources diretamente no editor. Se você mudar o nome ou o caminho do nó, a referência **não quebra**. O Inspector é a ferramenta que conecta seus sistemas de forma segura.
