Perfeito.
Agora entramos na virada de chave da s√©rie. Aqui o aluno come√ßa a pensar como arquiteto, n√£o como ‚Äúscriptador de cena‚Äù.

Vou manter o mesmo padr√£o da Aula 1:
‚û°Ô∏è coment√°rios falando com o aluno
‚û°Ô∏è did√°tico, direto e honesto
‚û°Ô∏è nada escondido debaixo do tapete

---

üìò AULA 2 ‚Äî SAVEMEMORY

Servers + Resources aplicados pela Yggdrasil

---

Objetivo da aula (para o aluno)

> Nesta aula voc√™ vai aprender que salvar jogo n√£o √© responsabilidade da cena,
> e que dados n√£o vivem em Nodes.

Voc√™ vai:

criar Resources para dados

criar um Server puro

usar a Yggdrasil como orquestradora

salvar e carregar o jogo sem acoplamento

---

üìÇ Estrutura do projeto (Aula 2)

core/
‚îú‚îÄ‚îÄ Yggdrasil.gd
‚îú‚îÄ‚îÄ SaveMemory.gd

data/
‚îú‚îÄ‚îÄ EntityData.gd
‚îú‚îÄ‚îÄ LevelData.gd
‚îú‚îÄ‚îÄ GameData.gd

levels/
‚îú‚îÄ‚îÄ level_01.tscn
‚îî‚îÄ‚îÄ level_01.gd

entities/
‚îú‚îÄ‚îÄ player.tscn
‚îî‚îÄ‚îÄ player.gd

---

üß† CONCEITO-CHAVE DA AULA

> Scene executa
> Resource armazena
> Server executa l√≥gica sem estado
> Yggdrasil decide quando

Repita isso at√© o aluno cansar.

---

üì¶ RESOURCE 1 ‚Äî EntityData.gd (CharacterSheet)

> Este Resource representa o personagem como dado,
> n√£o como Node.

EntityData.gd

extends Resource
class_name EntityData

# Identidade √∫nica da entidade

@export var uid: String
@export var display_name: String

# Status m√°ximos (design-time)

@export var max_health: int = 100
@export var max_stamina: int = 100

# Progress√£o

@export var unlocked_skills: Array[String] = []

# Invent√°rio simples (ser√° expandido na Aula 3)

@export var items: Dictionary = {}

# Dados de runtime que precisam ser salvos

@export var runtime := {
"health": 100,
"position": Vector2.ZERO,
"direction": Vector2.RIGHT
}

üìå Explique para o aluno:
Esse .tres √© usado durante o jogo e no save.
N√£o existe duplica√ß√£o de dados.

---

üì¶ RESOURCE 2 ‚Äî LevelData.gd

> Snapshot de um level inteiro.

LevelData.gd

extends Resource
class_name LevelData

# Identificador √∫nico do level

@export var level_uid: String

# Dados do level

# Nesta aula vamos focar apenas no player,

# mas essa estrutura j√° suporta inimigos, itens, etc.

@export var player_data: EntityData

---

üì¶ RESOURCE 3 ‚Äî GameData.gd

> Save unificado do jogo inteiro.

GameData.gd

extends Resource
class_name GameData

# Qual level o jogador estava

@export var current_level_uid: String = ""

# Dados dos levels salvos

# level_uid : LevelData

@export var levels: Dictionary = {}

---

üß† SERVER ‚Äî SaveMemory.gd

> Este √© um Server puro.
> N√£o √© Node, n√£o √© Autoload, n√£o guarda estado.

SaveMemory.gd

extends Object
class_name SaveMemory

const SAVE_PATH := "user://game_data.tres"

---

üíæ Salvar e carregar o jogo

func save_game(game_data: GameData) -> void: # Server n√£o decide nada. # Apenas executa.
ResourceSaver.save(game_data, SAVE_PATH)

func load_game() -> GameData:
if ResourceLoader.exists(SAVE_PATH):
return ResourceLoader.load(SAVE_PATH)

    # Se n√£o existir save, cria um novo
    return GameData.new()

---

üßç Coletar dados do Player

func collect_player(player: CharacterBody2D) -> EntityData: # Atualiza os dados de runtime antes de salvar
player.update_runtime_data()
return player.sheet

---

üó∫ Criar LevelData

func build_level_data(level_uid: String, player: CharacterBody2D) -> LevelData:
var level_data := LevelData.new()
level_data.level_uid = level_uid
level_data.player_data = collect_player(player)
return level_data

üìå Importante:
O Server n√£o sabe onde o player nasceu,
nem onde ele ser√° instanciado.

---

üéÆ PLAYER ‚Äî CharacterBody2D

player.gd

extends CharacterBody2D
class_name Player

# CharacterSheet do player

@export var sheet: EntityData

---

Aplicar dados do Resource

func apply_character_sheet(data: EntityData) -> void:
sheet = data

    # Seguran√ßa contra save corrompido
    sheet.runtime.health = clamp(
    	sheet.runtime.health,
    	0,
    	sheet.max_health
    )

    global_position = sheet.runtime.position

---

Atualizar dados antes do save

func update_runtime_data() -> void:
sheet.runtime.position = global_position

---

üß± LEVEL 01 ‚Äî Spawn do Player

level_01.gd

extends Node2D
class_name Level01

@export var level_uid: String = "level_01"
@export var player_scene: PackedScene

@onready var spawn_point: Marker2D = $SpawnPlayer

var player: Player

---

Spawn do player

func spawn_player(sheet: EntityData) -> Player:
player = player_scene.instantiate()
add_child(player)

    player.apply_character_sheet(sheet)

    # Se n√£o houver posi√ß√£o salva, usa o spawn
    if sheet.runtime.position == Vector2.ZERO:
    	player.global_position = spawn_point.global_position

    return player

---

üå≥ YGGDRASIL ‚Äî Agora com SaveMemory

Trecho novo em Yggdrasil.gd

var game_data: GameData

---

Load inicial

func \_ready() -> void:
game_data = SaveMemory.load_game()

    # Carrega level
    var level_uid := game_data.current_level_uid
    if level_uid == "":
    	level_uid = "level_01"

    # Instancia level
    level_atual = level_01_scene.instantiate()
    levels_root.add_child(level_atual)

    # Player
    var level_data: LevelData = game_data.levels.get(level_uid)
    if level_data:
    	level_atual.spawn_player(level_data.player_data)
    else:
    	# Novo jogo
    	level_atual.spawn_player(preload("res://data/player_sheet.tres"))

    _atualizar_estado(ESTADO.MENU)

---

Salvar jogo

func save_game() -> void:
var level_data := SaveMemory.build_level_data(
level_atual.level_uid,
level_atual.player
)

    game_data.levels[level_data.level_uid] = level_data
    game_data.current_level_uid = level_data.level_uid

    SaveMemory.save_game(game_data)

---

‚úÖ O QUE O ALUNO APRENDE NA AULA 2

‚úî Resource como fonte da verdade
‚úî Player n√£o salva a si mesmo
‚úî Server n√£o decide fluxo
‚úî Yggdrasil orquestra tudo
‚úî Save desacoplado de cena
‚úî Base s√≥lida para inventory e abilities

---

üß† FRASE PRA GRAVAR NO C√âREBRO DO ALUNO

> ‚ÄúSe o seu Node sabe salvar,
> ele j√° sabe coisa demais.‚Äù

---

Se quiser, pr√≥ximo passo:

Aula 3 completa (Inventory)

exerc√≠cios avaliativos dessa aula

vers√£o resumida pra slide

ou projeto incremental pros alunos continuarem

Isso aqui j√° √© forma√ß√£o de engine thinking.
